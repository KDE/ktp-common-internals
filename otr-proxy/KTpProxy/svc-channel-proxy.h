#ifndef KTP_PROXY_SVC_CHANNEL_PROXY_HEADER
#define KTP_PROXY_SVC_CHANNEL_PROXY_HEADER

/*
 * This file contains D-Bus adaptor classes generated by qt-svc-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */

#include <TelepathyQt/AbstractAdaptor>
#include <TelepathyQt/Global>
#include <TelepathyQt/Types>

#include <QObject>
#include <QtDBus>

namespace Tp
{
namespace Service
{

/**
 * \class ChannelProxyInterfaceOTRAdaptor
 * \headerfile TelepathyQt/_gen/svc-channel-proxy.h <TelepathyQt/_gen/svc-channel-proxy.h>
 * \ingroup servicechannelproxy
 *
 * Adaptor class providing a 1:1 mapping of the D-Bus interface "org.kde.TelepathyProxy.ChannelProxy.Interface.OTR".
 */
class TP_QT_EXPORT ChannelProxyInterfaceOTRAdaptor : public Tp::AbstractAdaptor
{
    Q_OBJECT
    Q_CLASSINFO("D-Bus Interface", "org.kde.TelepathyProxy.ChannelProxy.Interface.OTR")
    Q_CLASSINFO("D-Bus Introspection", ""
"  <interface name=\"org.kde.TelepathyProxy.ChannelProxy.Interface.OTR\">\n"
"    <property access=\"read\" type=\"o\" name=\"WrappedChannel\"/>\n"
"    <property access=\"read\" type=\"b\" name=\"Connected\"/>\n"
"    <property access=\"read\" type=\"aaa{sv}\" name=\"PendingMessages\">\n"
"      <annotation value=\"Tp::MessagePartListList\" name=\"com.trolltech.QtDBus.QtTypeName\"/>\n"
"    </property>\n"
"    <property access=\"read\" type=\"u\" name=\"TrustLevel\"/>\n"
"    <property access=\"read\" type=\"s\" name=\"LocalFingerprint\"/>\n"
"    <property access=\"read\" type=\"s\" name=\"RemoteFingerprint\"/>\n"
"    <method name=\"ConnectProxy\"/>\n"
"    <method name=\"DisconnectProxy\"/>\n"
"    <method name=\"SendMessage\">\n"
"      <arg direction=\"in\" type=\"aa{sv}\" name=\"message\">\n"
"        <annotation value=\"Tp::MessagePartList\" name=\"com.trolltech.QtDBus.QtTypeName.In0\"/>\n"
"      </arg>\n"
"      <arg direction=\"in\" type=\"u\" name=\"flags\"/>\n"
"      <arg direction=\"out\" type=\"s\" name=\"token\"/>\n"
"    </method>\n"
"    <method name=\"AcknowledgePendingMessages\">\n"
"      <arg direction=\"in\" type=\"au\" name=\"IDs\"/>\n"
"    </method>\n"
"    <method name=\"Initialize\"/>\n"
"    <method name=\"Stop\"/>\n"
"    <signal name=\"MessageSent\">\n"
"      <arg type=\"aa{sv}\" name=\"content\">\n"
"        <annotation value=\"Tp::MessagePartList\" name=\"com.trolltech.QtDBus.QtTypeName.In0\"/>\n"
"      </arg>\n"
"      <arg type=\"u\" name=\"flags\"/>\n"
"      <arg type=\"s\" name=\"messageToken\"/>\n"
"    </signal>\n"
"    <signal name=\"MessageReceived\">\n"
"      <arg type=\"aa{sv}\" name=\"message\">\n"
"        <annotation value=\"Tp::MessagePartList\" name=\"com.trolltech.QtDBus.QtTypeName.In0\"/>\n"
"      </arg>\n"
"    </signal>\n"
"    <signal name=\"PendingMessagesRemoved\">\n"
"      <arg type=\"au\" name=\"messageIDs\"/>\n"
"    </signal>\n"
"    <signal name=\"SessionRefreshed\"/>\n"
"  </interface>\n"
"")
    Q_PROPERTY(QDBusObjectPath WrappedChannel READ WrappedChannel )
    Q_PROPERTY(bool Connected READ Connected )
    Q_PROPERTY(Tp::MessagePartListList PendingMessages READ PendingMessages )
    Q_PROPERTY(uint TrustLevel READ TrustLevel )
    Q_PROPERTY(QString LocalFingerprint READ LocalFingerprint )
    Q_PROPERTY(QString RemoteFingerprint READ RemoteFingerprint )

public:
    ChannelProxyInterfaceOTRAdaptor(const QDBusConnection& dbusConnection, QObject* adaptee, QObject* parent);
    virtual ~ChannelProxyInterfaceOTRAdaptor();

    typedef Tp::MethodInvocationContextPtr<  > ConnectProxyContextPtr;
    typedef Tp::MethodInvocationContextPtr<  > DisconnectProxyContextPtr;
    typedef Tp::MethodInvocationContextPtr< QString > SendMessageContextPtr;
    typedef Tp::MethodInvocationContextPtr<  > AcknowledgePendingMessagesContextPtr;
    typedef Tp::MethodInvocationContextPtr<  > InitializeContextPtr;
    typedef Tp::MethodInvocationContextPtr<  > StopContextPtr;

public: // PROPERTIES
    /**
     * Return the value of the exported D-Bus object property \c WrappedChannel of type \c QDBusObjectPath.
     *
     * Adaptees should export this property as a Qt property named
     * 'wrappedChannel' with type QDBusObjectPath.
     *
     * 
     * \htmlonly
     * <p>Object path of the channel this proxy is created for.</p>
     * \endhtmlonly
     *
     * \return The value of exported property \c WrappedChannel.
     */
    QDBusObjectPath WrappedChannel() const;
    /**
     * Return the value of the exported D-Bus object property \c Connected of type \c bool.
     *
     * Adaptees should export this property as a Qt property named
     * 'connected' with type bool.
     *
     * 
     * \htmlonly
     * <p>TRUE if the proxy is connected</p>
     * \endhtmlonly
     *
     * \return The value of exported property \c Connected.
     */
    bool Connected() const;
    /**
     * Return the value of the exported D-Bus object property \c PendingMessages of type \c Tp::MessagePartListList.
     *
     * Adaptees should export this property as a Qt property named
     * 'pendingMessages' with type Tp::MessagePartListList.
     *
     * 
     * \htmlonly
     * <p>
     *   The same as:
     *    \endhtmlonly ChannelInterfaceMessagesInterface \htmlonly 
     * </p>
     * \endhtmlonly
     *
     * \return The value of exported property \c PendingMessages.
     */
    Tp::MessagePartListList PendingMessages() const;
    /**
     * Return the value of the exported D-Bus object property \c TrustLevel of type \c uint.
     *
     * Adaptees should export this property as a Qt property named
     * 'trustLevel' with type uint.
     *
     * 
     * \htmlonly
     * <p>The current trust level of this channel:
     *     0=TRUST_NOT_PRIVATE, 1=TRUST_UNVERIFIED, 2=TRUST_PRIVATE,
     *     3=TRUST_FINISHED</p>
     * <p>Clients MUST listen to PropertiesChanged to update UI when trust
     * level changes.</p>
     * \endhtmlonly
     *
     * \return The value of exported property \c TrustLevel.
     */
    uint TrustLevel() const;
    /**
     * Return the value of the exported D-Bus object property \c LocalFingerprint of type \c QString.
     *
     * Adaptees should export this property as a Qt property named
     * 'localFingerprint' with type QString.
     *
     * 
     * \htmlonly
     * <p>User's current fingerprint. The first element is a human readable
     * fingerprint that can be displayed to the user so he can communicate it
     * to the other end by other means so he can trust it. The 2nd element is
     * the fingerprint raw data.</p>
     * \endhtmlonly
     *
     * \return The value of exported property \c LocalFingerprint.
     */
    QString LocalFingerprint() const;
    /**
     * Return the value of the exported D-Bus object property \c RemoteFingerprint of type \c QString.
     *
     * Adaptees should export this property as a Qt property named
     * 'remoteFingerprint' with type QString.
     *
     * 
     * \htmlonly
     * <p>The current fingerprint of the remote contact. Should be displayed
     * to the user to update its trust level. The first element of the tuple
     * is the fingerprint formatted to be displayed. The 2nd element is the
     * fingerprint raw data that can be passed to TrustFingerprint</p>
     * \endhtmlonly
     *
     * \return The value of exported property \c RemoteFingerprint.
     */
    QString RemoteFingerprint() const;

public Q_SLOTS: // METHODS
    /**
     * Begins a call to the exported D-Bus method \c ConnectProxy on this object.
     *
     * Adaptees should export this method as a Qt slot with the following signature:
     * void connectProxy(const Tp::Service::ChannelProxyInterfaceOTRAdaptor::ConnectProxyContextPtr &context);
     *
     * Implementations should call MethodInvocationContext::setFinished (or setFinishedWithError
     * accordingly) on the received \a context object once the method has finished processing.
     *
     * 
     * Connect to the otr proxy. From now on all data which is modified by it 
     * should be acquired from the proxy, not from the underlying channel.
     *
     */
    void ConnectProxy(const QDBusMessage& dbusMessage);
    /**
     * Begins a call to the exported D-Bus method \c DisconnectProxy on this object.
     *
     * Adaptees should export this method as a Qt slot with the following signature:
     * void disconnectProxy(const Tp::Service::ChannelProxyInterfaceOTRAdaptor::DisconnectProxyContextPtr &context);
     *
     * Implementations should call MethodInvocationContext::setFinished (or setFinishedWithError
     * accordingly) on the received \a context object once the method has finished processing.
     *
     * 
     * Turns off proxy if one is connected.
     *
     */
    void DisconnectProxy(const QDBusMessage& dbusMessage);
    /**
     * Begins a call to the exported D-Bus method \c SendMessage on this object.
     *
     * Adaptees should export this method as a Qt slot with the following signature:
     * void sendMessage(const Tp::MessagePartList& message, uint flags, const Tp::Service::ChannelProxyInterfaceOTRAdaptor::SendMessageContextPtr &context);
     *
     * Implementations should call MethodInvocationContext::setFinished (or setFinishedWithError
     * accordingly) on the received \a context object once the method has finished processing.
     *
     * 
     * \htmlonly
     * <p>
     *   The same as:
     *    \endhtmlonly org.freedesktop.Telepathy.Channel.Interface.Messages.Sent \htmlonly 
     * </p>
     * \endhtmlonly
     *
     * \return
     */
    QString SendMessage(const Tp::MessagePartList& message, uint flags, const QDBusMessage& dbusMessage);
    /**
     * Begins a call to the exported D-Bus method \c AcknowledgePendingMessages on this object.
     *
     * Adaptees should export this method as a Qt slot with the following signature:
     * void acknowledgePendingMessages(const Tp::UIntList& IDs, const Tp::Service::ChannelProxyInterfaceOTRAdaptor::AcknowledgePendingMessagesContextPtr &context);
     *
     * Implementations should call MethodInvocationContext::setFinished (or setFinishedWithError
     * accordingly) on the received \a context object once the method has finished processing.
     *
     * 
     * \htmlonly
     * <p>
     *   The same as:
     *    \endhtmlonly ChannelTypeTextInterface \htmlonly 
     * </p>
     * \endhtmlonly
     *
     */
    void AcknowledgePendingMessages(const Tp::UIntList& IDs, const QDBusMessage& dbusMessage);
    /**
     * Begins a call to the exported D-Bus method \c Initialize on this object.
     *
     * Adaptees should export this method as a Qt slot with the following signature:
     * void initialize(const Tp::Service::ChannelProxyInterfaceOTRAdaptor::InitializeContextPtr &context);
     *
     * Implementations should call MethodInvocationContext::setFinished (or setFinishedWithError
     * accordingly) on the received \a context object once the method has finished processing.
     *
     * 
     * Start an OTR session for this channel if the remote end supports it has 
     * well.
     *
     */
    void Initialize(const QDBusMessage& dbusMessage);
    /**
     * Begins a call to the exported D-Bus method \c Stop on this object.
     *
     * Adaptees should export this method as a Qt slot with the following signature:
     * void stop(const Tp::Service::ChannelProxyInterfaceOTRAdaptor::StopContextPtr &context);
     *
     * Implementations should call MethodInvocationContext::setFinished (or setFinishedWithError
     * accordingly) on the received \a context object once the method has finished processing.
     *
     * 
     * Stops the OTR session.
     *
     */
    void Stop(const QDBusMessage& dbusMessage);

Q_SIGNALS: // SIGNALS
    /**
     * Represents the exported D-Bus signal \c MessageSent on this object.
     *
     * Adaptees should export this signal as a Qt signal with the following signature:
     * void messageSent(const Tp::MessagePartList& content, uint flags, const QString& messageToken);
     *
     * The adaptee signal will be automatically relayed as a D-Bus signal once emitted.
     *
     */
    void MessageSent(const Tp::MessagePartList& content, uint flags, const QString& messageToken);
    /**
     * Represents the exported D-Bus signal \c MessageReceived on this object.
     *
     * Adaptees should export this signal as a Qt signal with the following signature:
     * void messageReceived(const Tp::MessagePartList& message);
     *
     * The adaptee signal will be automatically relayed as a D-Bus signal once emitted.
     *
     */
    void MessageReceived(const Tp::MessagePartList& message);
    /**
     * Represents the exported D-Bus signal \c PendingMessagesRemoved on this object.
     *
     * Adaptees should export this signal as a Qt signal with the following signature:
     * void pendingMessagesRemoved(const Tp::UIntList& messageIDs);
     *
     * The adaptee signal will be automatically relayed as a D-Bus signal once emitted.
     *
     */
    void PendingMessagesRemoved(const Tp::UIntList& messageIDs);
    /**
     * Represents the exported D-Bus signal \c SessionRefreshed on this object.
     *
     * Adaptees should export this signal as a Qt signal with the following signature:
     * void sessionRefreshed();
     *
     * The adaptee signal will be automatically relayed as a D-Bus signal once emitted.
     *
     */
    void SessionRefreshed();
};

}
}

#endif
